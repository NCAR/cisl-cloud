# fullnameOverride and nameOverride distinguishes blank strings, null values,
# and non-blank strings. For more details, see the configuration reference.
fullnameOverride: ""
nameOverride:

# custom can contain anything you want to pass to the hub pod, as all passed
# Helm template values will be made available there.
custom: {}

# imagePullSecret is configuration to create a k8s Secret that Helm chart's pods
# can get credentials from to pull their images.
imagePullSecret:
  create: false
  automaticReferenceInjection: true
  registry:
  username:
  password:
  email:
# imagePullSecrets is configuration to reference the k8s Secret resources the
# Helm chart's pods can get credentials from to pull their images.
imagePullSecrets: []

# hub relates to the hub pod, responsible for running JupyterHub, its configured
# Authenticator class KubeSpawner, and its configured Proxy class
# ConfigurableHTTPProxy. KubeSpawner creates the user pods, and
# ConfigurableHTTPProxy speaks with the actual ConfigurableHTTPProxy server in
# the proxy pod.

hub:
#  services:
#    dask-gateway:
#      display: false
  config:
    JupyterHub:
      authenticator_class: github
    GitHubOAuthenticator:
      client_id: 
      client_secret: 
      oauth_callback_url: https://jupyter.k8s.ucar.edu/hub/oauth_callback
      allowed_organizations:
        - NCAR:2i2c-cloud-users
      scope:
        - read:org
    Authenticator:
      admin_users:
        - kcote-ncar # Ken Cote, Initial adminstrator
        - NicholasCote # Nicholas Cote, Initial adminstrator
        - nwehrheim # Nick Wehrheim, Community representative

#hub:
#  revisionHistoryLimit:
#  config:
#    JupyterHub:
#      admin_access: true
#      authenticator_class: dummy
#    Authenticator:
#      admin_users:
#        - kcoteadmin
  service:
    #type: LoadBalancer
    type: ClusterIP
    annotations: {}
    ports:
      nodePort:
    extraPorts: []
    loadBalancerIP:
  baseUrl: /
  cookieSecret:
  initContainers: []
  nodeSelector: {}
  tolerations: []
  concurrentSpawnLimit: 64
  consecutiveFailureLimit: 5
  activeServerLimit:
  deploymentStrategy:
    ## type: Recreate
    ## - sqlite-pvc backed hubs require the Recreate deployment strategy as a
    ##   typical PVC storage can only be bound to one pod at the time.
    ## - JupyterHub isn't designed to support being run in parallell. More work
    ##   needs to be done in JupyterHub itself for a fully highly available (HA)
    ##   deployment of JupyterHub on k8s is to be possible.
    type: Recreate
  db:
    type: sqlite-pvc
    upgrade:
    pvc:
      annotations: {}
      selector: {}
      accessModes:
        - ReadWriteOnce
      storage: 1Gi
      subPath:
      storageClassName: ceph-block
    url:
    password:
  labels: {}
  annotations: {}
  command: []
  args: []
  extraConfig: {}
  extraFiles: {}
  extraEnv: {}
  extraContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  image:
    name: jupyterhub/k8s-hub
    tag: "2.0.0"
    pullPolicy:
    pullSecrets: []
  resources: {}
  podSecurityContext:
    fsGroup: 1000
  containerSecurityContext:
    runAsUser: 1000
    runAsGroup: 1000
    allowPrivilegeEscalation: false
  lifecycle: {}
  loadRoles: {}
  services: {}
  pdb:
    enabled: false
    maxUnavailable:
    minAvailable: 1
  networkPolicy:
    enabled: true
    ingress: []
    egress: []
    egressAllowRules:
      cloudMetadataServer: true
      dnsPortsPrivateIPs: true
      nonPrivateIPs: true
      privateIPs: true
    interNamespaceAccessLabels: ignore
    allowedIngressPorts: []
  allowNamedServers: false
  namedServerLimitPerUser:
  authenticatePrometheus:
  redirectToServer:
  shutdownOnLogout:
  templatePaths: []
  templateVars: {}
  livenessProbe:
    # The livenessProbe's aim to give JupyterHub sufficient time to startup but
    # be able to restart if it becomes unresponsive for ~5 min.
    enabled: true
    initialDelaySeconds: 300
    periodSeconds: 10
    failureThreshold: 30
    timeoutSeconds: 3
  readinessProbe:
    # The readinessProbe's aim is to provide a successful startup indication,
    # but following that never become unready before its livenessProbe fail and
    # restarts it if needed. To become unready following startup serves no
    # purpose as there are no other pod to fallback to in our non-HA deployment.
    enabled: true
    initialDelaySeconds: 0
    periodSeconds: 2
    failureThreshold: 1000
    timeoutSeconds: 1
  existingSecret:
  serviceAccount:
    create: true
    name:
    annotations: {}
  extraPodSpec: {}

rbac:
  create: true

# proxy relates to the proxy pod, the proxy-public service, and the autohttps
# pod and proxy-http service.
proxy:
  secretToken: ''
  annotations: {}
  deploymentStrategy:
    ## type: Recreate
    ## - JupyterHub's interaction with the CHP proxy becomes a lot more robust
    ##   with this configuration. To understand this, consider that JupyterHub
    ##   during startup will interact a lot with the k8s service to reach a
    ##   ready proxy pod. If the hub pod during a helm upgrade is restarting
    ##   directly while the proxy pod is making a rolling upgrade, the hub pod
    ##   could end up running a sequence of interactions with the old proxy pod
    ##   and finishing up the sequence of interactions with the new proxy pod.
    ##   As CHP proxy pods carry individual state this is very error prone. One
    ##   outcome when not using Recreate as a strategy has been that user pods
    ##   have been deleted by the hub pod because it considered them unreachable
    ##   as it only configured the old proxy pod but not the new before trying
    ##   to reach them.
    type: Recreate
    ## rollingUpdate:
    ## - WARNING:
    ##   This is required to be set explicitly blank! Without it being
    ##   explicitly blank, k8s will let eventual old values under rollingUpdate
    ##   remain and then the Deployment becomes invalid and a helm upgrade would
    ##   fail with an error like this:
    ##
    ##     UPGRADE FAILED
    ##     Error: Deployment.apps "proxy" is invalid: spec.strategy.rollingUpdate: Forbidden: may not be specified when strategy `type` is 'Recreate'
    ##     Error: UPGRADE FAILED: Deployment.apps "proxy" is invalid: spec.strategy.rollingUpdate: Forbidden: may not be specified when strategy `type` is 'Recreate'
    rollingUpdate:
  # service relates to the proxy-public service
  service:
    type: NodePort
    labels: {}
    annotations: {}
    nodePorts:
      http:
      https:
    disableHttpPort: false
    extraPorts: []
    loadBalancerIP:
    loadBalancerSourceRanges: []
  # chp relates to the proxy pod, which is responsible for routing traffic based
  # on dynamic configuration sent from JupyterHub to CHP's REST API.
  chp:
    revisionHistoryLimit:
    containerSecurityContext:
      runAsUser: 65534 # nobody user
      runAsGroup: 65534 # nobody group
      allowPrivilegeEscalation: false
    image:
      name: jupyterhub/configurable-http-proxy
      # tag is automatically bumped to new patch versions by the
      # watch-dependencies.yaml workflow.
      #
      tag: "4.5.3" # https://github.com/jupyterhub/configurable-http-proxy/releases
      pullPolicy:
      pullSecrets: []
    extraCommandLineFlags: []
    livenessProbe:
      enabled: true
      initialDelaySeconds: 60
      periodSeconds: 10
      failureThreshold: 30
      timeoutSeconds: 3
    readinessProbe:
      enabled: true
      initialDelaySeconds: 0
      periodSeconds: 2
      failureThreshold: 1000
      timeoutSeconds: 1
    resources: {}
    defaultTarget:
    errorTarget:
    extraEnv: {}
    nodeSelector: {}
    tolerations: []
    networkPolicy:
      enabled: true
      ingress: []
      egress: []
      egressAllowRules:
        cloudMetadataServer: true
        dnsPortsPrivateIPs: true
        nonPrivateIPs: true
        privateIPs: true
      interNamespaceAccessLabels: ignore
      allowedIngressPorts: [http, https]
    pdb:
      enabled: false
      maxUnavailable:
      minAvailable: 1
    extraPodSpec: {}
  # traefik relates to the autohttps pod, which is responsible for TLS
  # termination when proxy.https.type=letsencrypt.
  traefik:
    revisionHistoryLimit:
    containerSecurityContext:
      runAsUser: 65534 # nobody user
      runAsGroup: 65534 # nobody group
      allowPrivilegeEscalation: false
    image:
      name: traefik
      # tag is automatically bumped to new patch versions by the
      # watch-dependencies.yaml workflow.
      #
      tag: "v2.8.4" # ref: https://hub.docker.com/_/traefik?tab=tags
      pullPolicy:
      pullSecrets: []
    hsts:
      includeSubdomains: false
      preload: false
      maxAge: 15724800 # About 6 months
    resources: {}
    labels: {}
    extraInitContainers: []
    extraEnv: {}
    extraVolumes: []
    extraVolumeMounts: []
    extraStaticConfig: {}
    extraDynamicConfig: {}
    nodeSelector: {}
    tolerations: []
    extraPorts: []
    networkPolicy:
      enabled: true
      ingress: []
      egress: []
      egressAllowRules:
        cloudMetadataServer: true
        dnsPortsPrivateIPs: true
        nonPrivateIPs: true
        privateIPs: true
      interNamespaceAccessLabels: ignore
      allowedIngressPorts: [http, https]
    pdb:
      enabled: false
      maxUnavailable:
      minAvailable: 1
    serviceAccount:
      create: true
      name:
      annotations: {}
    extraPodSpec: {}
  secretSync:
    containerSecurityContext:
      runAsUser: 65534 # nobody user
      runAsGroup: 65534 # nobody group
      allowPrivilegeEscalation: false
    image:
      name: jupyterhub/k8s-secret-sync
      tag: "2.0.0"
      pullPolicy:
      pullSecrets: []
    resources: {}
  labels: {}
  https:
    enabled: false
    type: letsencrypt
    #type: letsencrypt, manual, offload, secret
    letsencrypt:
      contactEmail:
      # Specify custom server here (https://acme-staging-v02.api.letsencrypt.org/directory) to hit staging LE
      acmeServer: https://acme-v02.api.letsencrypt.org/directory
    manual:
      key:
      cert:
    secret:
      name:
      key: tls.key
      crt: tls.crt
    hosts: []

# singleuser relates to the configuration of KubeSpawner which runs in the hub
# pod, and its spawning of user pods such as jupyter-myusername.
singleuser:
  podNameTemplate:
  extraTolerations: []
  nodeSelector: {}
  extraNodeAffinity:
    required: []
    preferred: []
  extraPodAffinity:
    required: []
    preferred: []
  extraPodAntiAffinity:
    required: []
    preferred: []
  networkTools:
    image:
      name: jupyterhub/k8s-network-tools
      tag: "2.0.0"
      pullPolicy:
      pullSecrets: []
    resources: {}
  cloudMetadata:
    # block set to true will append a privileged initContainer using the
    # iptables to block the sensitive metadata server at the provided ip.
    blockWithIptables: true
    ip: 169.254.169.254
  networkPolicy:
    enabled: true
    ingress: []
    egress: []
    egressAllowRules:
      cloudMetadataServer: false
      dnsPortsPrivateIPs: true
      nonPrivateIPs: true
      privateIPs: false
    interNamespaceAccessLabels: ignore
    allowedIngressPorts: []
  events: true
  extraAnnotations: {}
  extraLabels:
    hub.jupyter.org/network-access-hub: "true"
  extraFiles: {}
  extraEnv: {}
  lifecycleHooks: {}
  initContainers: []
  extraContainers: []
  allowPrivilegeEscalation: false
  uid: 1000
  fsGid: 100
  serviceAccountName:
  storage:
    type: dynamic
    extraLabels: {}
#    extraVolumes: []
#    extraVolumeMounts: []
    extraVolumes:
        - name: nfs-volume
          nfs:
              server: sisgs200.nwsc.ucar.edu
              path: /mnt/nwscsisds01/jupyter/shared
        #- name: glade-collections
        #  nfs:
        #      server: gladedm1.ucar.edu
        #      path: /gpfs/fs1/collections
        #- name: campaign
        #  nfs:
        #      server: gladedm1.ucar.edu
        #      path: /gpfs/csfs1
    extraVolumeMounts:
        - name: nfs-volume
          mountPath: /home/jovyan/shared
          readOnly: true
        #- name: glade-collections
        #  mountPath: /home/jovyan/glade/collections
        #  readOnly: true
        #- name: campaign
        #  mountPath: /home/jovyan/glade/campaign
        #  readOnly: true
#    extraVolumes:
#      - name: jupyterhub-shared
#        persistentVolumeClaim:
#          claimName: jupyterhub-shared-volume
#    extraVolumeMounts:
#      - name: jupyterhub-shared
#        mountPath: /home/shared
    static:
      pvcName:
      subPath: "{username}"
    capacity: 10Gi
    homeMountPath: /home/jovyan
    dynamic:
      storageClass: ceph-block
      pvcNameTemplate: claim-{username}{servername}
      volumeNameTemplate: volume-{username}{servername}
      storageAccessModes: [ReadWriteOnce]
  image:
    # image choice preliminary and is expected to be setup via
    # https://ncar-cisl.2i2c.cloud/services/configurator/ by the community
    #
    # pangeo/pangeo-notebook is maintained at: https://github.com/pangeo-data/pangeo-docker-images
    name: pangeo/pangeo-notebook
    tag: "2023.05.18"
  profileList:
    # NOTE: About node sharing
    #
    #       CPU/Memory requests/limits are actively considered still. This
    #       profile list is setup to involve node sharing as considered in
    #       https://github.com/2i2c-org/infrastructure/issues/2121.
    #
    #       - Memory requests are different from the description, based on:
    #         whats found to remain allocate in k8s, subtracting 1GiB
    #         overhead for misc system pods, and transitioning from GB in
    #         description to GiB in mem_guarantee.
    #       - CPU requests are lower than the description, with a factor of
    #         10%.
    #
    - display_name: "Small: up to 4 CPU / 32 GB RAM"
      description: &profile_list_description "Start a container with at least a chosen share of capacity on a node of this type"
      slug: small
      default: true
      profile_options:
        requests:
          # NOTE: Node share choices are in active development, see comment
          #       next to profileList: above.
          display_name: Node share
          choices:
            mem_1:
              default: true
              display_name: ~1 GB, ~0.125 CPU
              kubespawner_override:
                mem_guarantee: 0.904G
                cpu_guarantee: 0.013
            mem_2:
              display_name: ~2 GB, ~0.25 CPU
              kubespawner_override:
                mem_guarantee: 1.809G
                cpu_guarantee: 0.025
            mem_4:
              display_name: ~4 GB, ~0.5 CPU
              kubespawner_override:
                mem_guarantee: 3.617G
                cpu_guarantee: 0.05
            mem_8:
              display_name: ~8 GB, ~1.0 CPU
              kubespawner_override:
                mem_guarantee: 7.234G
                cpu_guarantee: 0.1
            mem_16:
              display_name: ~16 GB, ~2.0 CPU
              kubespawner_override:
                mem_guarantee: 14.469G
                cpu_guarantee: 0.2
            mem_32:
              display_name: ~32 GB, ~4.0 CPU
              kubespawner_override:
                mem_guarantee: 28.937G
                cpu_guarantee: 0.4
      kubespawner_override:
        cpu_limit: null
        mem_limit: null
#        node_selector:
#          node.kubernetes.io/instance-type: r5.xlarge
    - display_name: "Medium: up to 16 CPU / 128 GB RAM"
      description: *profile_list_description
      slug: medium
      profile_options:
        requests:
          # NOTE: Node share choices are in active development, see comment
          #       next to profileList: above.
          display_name: Node share
          choices:
            mem_1:
              display_name: ~1 GB, ~0.125 CPU
              kubespawner_override:
                mem_guarantee: 0.942G
                cpu_guarantee: 0.013
            mem_2:
              display_name: ~2 GB, ~0.25 CPU
              kubespawner_override:
                mem_guarantee: 1.883G
                cpu_guarantee: 0.025
            mem_4:
              default: true
              display_name: ~4 GB, ~0.5 CPU
              kubespawner_override:
                mem_guarantee: 3.766G
                cpu_guarantee: 0.05
            mem_8:
              display_name: ~8 GB, ~1.0 CPU
              kubespawner_override:
                mem_guarantee: 7.532G
                cpu_guarantee: 0.1
            mem_16:
              display_name: ~16 GB, ~2.0 CPU
              kubespawner_override:
                mem_guarantee: 15.064G
                cpu_guarantee: 0.2
            mem_32:
              display_name: ~32 GB, ~4.0 CPU
              kubespawner_override:
                mem_guarantee: 30.128G
                cpu_guarantee: 0.4
            mem_64:
              display_name: ~64 GB, ~8.0 CPU
              kubespawner_override:
                mem_guarantee: 60.257G
                cpu_guarantee: 0.8
            mem_128:
              display_name: ~128 GB, ~16.0 CPU
              kubespawner_override:
                mem_guarantee: 120.513G
                cpu_guarantee: 1.6
      kubespawner_override:
        cpu_limit: null
        mem_limit: null
#        node_selector:
#          node.kubernetes.io/instance-type: r5.4xlarge
    - display_name: "Large: up to 64 CPU / 512 GB RAM"
      description: *profile_list_description
      slug: large
      profile_options:
        requests:
          # NOTE: Node share choices are in active development, see comment
          #       next to profileList: above.
          display_name: Node share
          choices:
            mem_4:
              display_name: ~4 GB, ~0.5 CPU
              kubespawner_override:
                mem_guarantee: 3.821G
                cpu_guarantee: 0.05
            mem_8:
              display_name: ~8 GB, ~1.0 CPU
              kubespawner_override:
                mem_guarantee: 7.643G
                cpu_guarantee: 0.1
            mem_16:
              default: true
              display_name: ~16 GB, ~2.0 CPU
              kubespawner_override:
                mem_guarantee: 15.285G
                cpu_guarantee: 0.2
            mem_32:
              display_name: ~32 GB, ~4.0 CPU
              kubespawner_override:
                mem_guarantee: 30.571G
                cpu_guarantee: 0.4
            mem_64:
              display_name: ~64 GB, ~8.0 CPU
              kubespawner_override:
                mem_guarantee: 61.141G
                cpu_guarantee: 0.8
            mem_128:
              display_name: ~128 GB, ~16.0 CPU
              kubespawner_override:
                mem_guarantee: 122.282G
                cpu_guarantee: 1.6
            mem_256:
              display_name: ~256 GB, ~32.0 CPU
              kubespawner_override:
                mem_guarantee: 244.565G
                cpu_guarantee: 3.2
            mem_512:
              display_name: ~512 GB, ~64.0 CPU
              kubespawner_override:
                mem_guarantee: 489.13G
                cpu_guarantee: 6.4
      kubespawner_override:
        cpu_limit: null
        mem_limit: null
#        node_selector:
#          node.kubernetes.io/instance-type: r5.16xlarge

#    - display_name: NVIDIA Tesla T4, ~16 GB, ~4 CPUs
#      slug: gpu
#      description: "Start a container on a dedicated node with a GPU"
#      profile_options:
#        image:
#          display_name: Image
#          choices:
#            tensorflow:
#              display_name: Pangeo Tensorflow ML Notebook
#              slug: "tensorflow"
#              kubespawner_override:
#                image: "pangeo/ml-notebook:2023.05.18"
#            pytorch:
#              display_name: Pangeo PyTorch ML Notebook
#              default: true
#              slug: "pytorch"
#              kubespawner_override:
#                image: "pangeo/pytorch-notebook:2023.05.18"
#      kubespawner_override:
#        mem_limit: null
#        mem_guarantee: 14G
#        environment:
#          NVIDIA_DRIVER_CAPABILITIES: compute,utility
##        node_selector:
##          node.kubernetes.io/instance-type: g4dn.xlarge
#        extra_resource_limits:
#          nvidia.com/gpu: "1"
    - display_name: "Test NCAR Custom"
      description: "6 GB of memory; up to 4 vCPUS"
      profile_options:
        image:
          display_name: Latest
          choices:
            tensorflow:
              display_name: NCAR Latest Test
              slug: "ncar"
              kubespawner_override:
                image: "ncote/cisl-cloud-base:latest"
      kubespawner_override:
          mem_guarantee: 2G
          mem_limit: 6G
          cpu_guarantee: 1
          cpu_limit: 4

# scheduling relates to the user-scheduler pods and user-placeholder pods.
scheduling:
  userScheduler:
    enabled: true
    revisionHistoryLimit:
    replicas: 2
    logLevel: 4
    # plugins are configured on the user-scheduler to make us score how we
    # schedule user pods in a way to help us schedule on the most busy node. By
    # doing this, we help scale down more effectively. It isn't obvious how to
    # enable/disable scoring plugins, and configure them, to accomplish this.
    #
    # plugins ref: https://kubernetes.io/docs/reference/scheduling/config/#scheduling-plugins-1
    # migration ref: https://kubernetes.io/docs/reference/scheduling/config/#scheduler-configuration-migrations
    #
    plugins:
      score:
        # These scoring plugins are enabled by default according to
        # https://kubernetes.io/docs/reference/scheduling/config/#scheduling-plugins
        # 2022-02-22.
        #
        # Enabled with high priority:
        # - NodeAffinity
        # - InterPodAffinity
        # - NodeResourcesFit
        # - ImageLocality
        # Remains enabled with low default priority:
        # - TaintToleration
        # - PodTopologySpread
        # - VolumeBinding
        # Disabled for scoring:
        # - NodeResourcesBalancedAllocation
        #
        disabled:
          # We disable these plugins (with regards to scoring) to not interfere
          # or complicate our use of NodeResourcesFit.
          - name: NodeResourcesBalancedAllocation
          # Disable plugins to be allowed to enable them again with a different
          # weight and avoid an error.
          - name: NodeAffinity
          - name: InterPodAffinity
          - name: NodeResourcesFit
          - name: ImageLocality
        enabled:
          - name: NodeAffinity
            weight: 14631
          - name: InterPodAffinity
            weight: 1331
          - name: NodeResourcesFit
            weight: 121
          - name: ImageLocality
            weight: 11
    pluginConfig:
      # Here we declare that we should optimize pods to fit based on a
      # MostAllocated strategy instead of the default LeastAllocated.
      - name: NodeResourcesFit
        args:
          scoringStrategy:
            resources:
              - name: cpu
                weight: 1
              - name: memory
                weight: 1
            type: MostAllocated
    containerSecurityContext:
      runAsUser: 65534 # nobody user
      runAsGroup: 65534 # nobody group
      allowPrivilegeEscalation: false
    image:
      # IMPORTANT: Bumping the minor version of this binary should go hand in
      #            hand with an inspection of the user-scheduelrs RBAC resources
      #            that we have forked in
      #            templates/scheduling/user-scheduler/rbac.yaml.
      #
      #            Debugging advice:
      #
      #            - Is configuration of kube-scheduler broken in
      #              templates/scheduling/user-scheduler/configmap.yaml?
      #
      #            - Is the kube-scheduler binary's compatibility to work
      #              against a k8s api-server that is too new or too old?
      #
      #            - You can update the GitHub workflow that runs tests to
      #              include "deploy/user-scheduler" in the k8s namespace report
      #              and reduce the user-scheduler deployments replicas to 1 in
      #              dev-config.yaml to get relevant logs from the user-scheduler
      #              pods. Inspect the "Kubernetes namespace report" action!
      #
      #            - Typical failures are that kube-scheduler fails to search for
      #              resources via its "informers", and won't start trying to
      #              schedule pods before they succeed which may require
      #              additional RBAC permissions or that the k8s api-server is
      #              aware of the resources.
      #
      #            - If "successfully acquired lease" can be seen in the logs, it
      #              is a good sign kube-scheduler is ready to schedule pods.
      #
      name: k8s.gcr.io/kube-scheduler
      # tag is automatically bumped to new patch versions by the
      # watch-dependencies.yaml workflow. The minor version is pinned in the
      # workflow, and should be updated there if a minor version bump is done
      # here.
      #
      tag: "v1.23.10" # ref: https://github.com/kubernetes/website/blob/main/content/en/releases/patch-releases.md
      pullPolicy:
      pullSecrets: []
    nodeSelector: {}
    tolerations: []
    labels: {}
    annotations: {}
    pdb:
      enabled: true
      maxUnavailable: 1
      minAvailable:
    resources: {}
    serviceAccount:
      create: true
      name:
      annotations: {}
    extraPodSpec: {}
  podPriority:
    enabled: false
    globalDefault: false
    defaultPriority: 0
    imagePullerPriority: -5
    userPlaceholderPriority: -10
  userPlaceholder:
    enabled: true
    image:
      name: k8s.gcr.io/pause
      # tag is automatically bumped to new patch versions by the
      # watch-dependencies.yaml workflow.
      #
      # If you update this, also update prePuller.pause.image.tag
      #
      tag: "3.8"
      pullPolicy:
      pullSecrets: []
    revisionHistoryLimit:
    replicas: 0
    labels: {}
    annotations: {}
    containerSecurityContext:
      runAsUser: 65534 # nobody user
      runAsGroup: 65534 # nobody group
      allowPrivilegeEscalation: false
    resources: {}
  corePods:
    tolerations:
      - key: hub.jupyter.org/dedicated
        operator: Equal
        value: core
        effect: NoSchedule
      - key: hub.jupyter.org_dedicated
        operator: Equal
        value: core
        effect: NoSchedule
    nodeAffinity:
      matchNodePurpose: prefer
  userPods:
    tolerations:
      - key: hub.jupyter.org/dedicated
        operator: Equal
        value: user
        effect: NoSchedule
      - key: hub.jupyter.org_dedicated
        operator: Equal
        value: user
        effect: NoSchedule
    nodeAffinity:
      matchNodePurpose: prefer

# prePuller relates to the hook|continuous-image-puller DaemonsSets
prePuller:
  revisionHistoryLimit:
  labels: {}
  annotations: {}
  resources: {}
  containerSecurityContext:
    runAsUser: 65534 # nobody user
    runAsGroup: 65534 # nobody group
    allowPrivilegeEscalation: false
  extraTolerations: []
  # hook relates to the hook-image-awaiter Job and hook-image-puller DaemonSet
  hook:
    enabled: true
    pullOnlyOnChanges: true
    # image and the configuration below relates to the hook-image-awaiter Job
    image:
      name: jupyterhub/k8s-image-awaiter
      tag: "2.0.0"
      pullPolicy:
      pullSecrets: []
    containerSecurityContext:
      runAsUser: 65534 # nobody user
      runAsGroup: 65534 # nobody group
      allowPrivilegeEscalation: false
    podSchedulingWaitDuration: 10
    nodeSelector: {}
    tolerations: []
    resources: {}
    serviceAccount:
      create: true
      name:
      annotations: {}
  continuous:
    enabled: true
  pullProfileListImages: true
  extraImages: {}
  pause:
    containerSecurityContext:
      runAsUser: 65534 # nobody user
      runAsGroup: 65534 # nobody group
      allowPrivilegeEscalation: false
    image:
      name: k8s.gcr.io/pause
      # tag is automatically bumped to new patch versions by the
      # watch-dependencies.yaml workflow.
      #
      # If you update this, also update scheduling.userPlaceholder.image.tag
      #
      tag: "3.8"
      pullPolicy:
      pullSecrets: []

#ingress:
#  enabled: false
#  annotations: {}
#  ingressClassName:
#  hosts: []
#  pathSuffix:
#  pathType: Prefix
#  tls: []

ingress:
  enabled: true
#  annotations: {}
  annotations:
#    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/proxy-body-size: 600m
    nginx.org/client-max-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "1800"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "1800"
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/secure-backends: "true"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/websocket-services: proxy-public
    nginx.org/websocket-services: proxy-public
    cert-manager.io/cluster-issuer: "incommon"
  ingressClassName: nginx
  hosts: [jupyter.k8s.ucar.edu]
  tls:
    - hosts:
        - jupyter.k8s.ucar.edu
      secretName: https-auto-incommon
#  rules:
#    - host: jupyter.k8s.ucar.edu
#      http:
#        paths:
#        - path: /
#          pathType: Prefix
#          backend:
#            service:
#              name: proxy-public
#              port: 
#                number: 80

# cull relates to the jupyterhub-idle-culler service, responsible for evicting
# inactive singleuser pods.
#
# The configuration below, except for enabled, corresponds to command-line flags
# for jupyterhub-idle-culler as documented here:
# https://github.com/jupyterhub/jupyterhub-idle-culler#as-a-standalone-script
#
cull:
  enabled: true
  users: false # --cull-users
  adminUsers: true # --cull-admin-users
  removeNamedServers: false # --remove-named-servers
  timeout: 3600 # --timeout
  every: 600 # --cull-every
  concurrency: 10 # --concurrency
  maxAge: 0 # --max-age

debug:
  enabled: false

global:
  safeToShowValues: false

